{"ast":null,"code":"import * as React from \"react\";\nimport { useEventCallback } from \"../../hooks/index.js\";\nimport { useTimeouts } from \"../../contexts/index.js\";\nimport { SwipeState } from \"./index.js\";\nimport { EVENT_ON_WHEEL } from \"../../consts.js\";\nexport var useWheelSwipe = function useWheelSwipe(swipeState, subscribeSensors, isSwipeValid, containerWidth, swipeAnimationDuration, onSwipeStart, onSwipeProgress, onSwipeFinish, onSwipeCancel) {\n  var offset = React.useRef(0);\n  var intent = React.useRef(0);\n  var intentCleanup = React.useRef();\n  var resetCleanup = React.useRef();\n  var wheelResidualMomentum = React.useRef(0);\n  var startTime = React.useRef(0);\n\n  var _useTimeouts = useTimeouts(),\n      setTimeout = _useTimeouts.setTimeout,\n      clearTimeout = _useTimeouts.clearTimeout;\n\n  var cancelSwipeIntentCleanup = React.useCallback(function () {\n    if (intentCleanup.current) {\n      clearTimeout(intentCleanup.current);\n      intentCleanup.current = undefined;\n    }\n  }, [clearTimeout]);\n  var cancelSwipeResetCleanup = React.useCallback(function () {\n    if (resetCleanup.current) {\n      clearTimeout(resetCleanup.current);\n      resetCleanup.current = undefined;\n    }\n  }, [clearTimeout]);\n  var handleCleanup = useEventCallback(function () {\n    if (swipeState !== SwipeState.SWIPE) {\n      offset.current = 0;\n      startTime.current = 0;\n      cancelSwipeIntentCleanup();\n      cancelSwipeResetCleanup();\n    }\n  });\n  React.useEffect(handleCleanup, [swipeState, handleCleanup]);\n  var handleCancelSwipe = useEventCallback(function (currentSwipeOffset) {\n    resetCleanup.current = undefined;\n\n    if (offset.current === currentSwipeOffset) {\n      onSwipeCancel(offset.current);\n    }\n  });\n  var onWheel = useEventCallback(function (event) {\n    if (event.ctrlKey) {\n      return;\n    }\n\n    if (Math.abs(event.deltaY) > Math.abs(event.deltaX)) {\n      return;\n    }\n\n    if (!swipeState) {\n      if (Math.abs(event.deltaX) <= 1.2 * Math.abs(wheelResidualMomentum.current)) {\n        wheelResidualMomentum.current = event.deltaX;\n        return;\n      }\n\n      if (!isSwipeValid(-event.deltaX)) {\n        return;\n      }\n\n      intent.current += event.deltaX;\n      cancelSwipeIntentCleanup();\n\n      if (Math.abs(intent.current) > 30) {\n        intent.current = 0;\n        wheelResidualMomentum.current = 0;\n        startTime.current = Date.now();\n        onSwipeStart();\n      } else {\n        var currentSwipeIntent = intent.current;\n        intentCleanup.current = setTimeout(function () {\n          intentCleanup.current = undefined;\n\n          if (currentSwipeIntent === intent.current) {\n            intent.current = 0;\n          }\n        }, swipeAnimationDuration);\n      }\n    } else if (swipeState === SwipeState.SWIPE) {\n      var newSwipeOffset = offset.current - event.deltaX;\n      newSwipeOffset = Math.min(Math.abs(newSwipeOffset), containerWidth) * Math.sign(newSwipeOffset);\n      offset.current = newSwipeOffset;\n      onSwipeProgress(newSwipeOffset);\n      cancelSwipeResetCleanup();\n\n      if (Math.abs(newSwipeOffset) > 0.2 * containerWidth) {\n        wheelResidualMomentum.current = event.deltaX;\n        onSwipeFinish(newSwipeOffset, Date.now() - startTime.current);\n        return;\n      }\n\n      resetCleanup.current = setTimeout(function () {\n        return handleCancelSwipe(newSwipeOffset);\n      }, 2 * swipeAnimationDuration);\n    } else {\n      wheelResidualMomentum.current = event.deltaX;\n    }\n  });\n  React.useEffect(function () {\n    return subscribeSensors(EVENT_ON_WHEEL, onWheel);\n  }, [subscribeSensors, onWheel]);\n};","map":{"version":3,"names":["React","useEventCallback","useTimeouts","SwipeState","EVENT_ON_WHEEL","useWheelSwipe","swipeState","subscribeSensors","isSwipeValid","containerWidth","swipeAnimationDuration","onSwipeStart","onSwipeProgress","onSwipeFinish","onSwipeCancel","offset","useRef","intent","intentCleanup","resetCleanup","wheelResidualMomentum","startTime","setTimeout","clearTimeout","cancelSwipeIntentCleanup","useCallback","current","undefined","cancelSwipeResetCleanup","handleCleanup","SWIPE","useEffect","handleCancelSwipe","currentSwipeOffset","onWheel","event","ctrlKey","Math","abs","deltaY","deltaX","Date","now","currentSwipeIntent","newSwipeOffset","min","sign"],"sources":["/Users/kubilaybozak/Desktop/Tatto-Template/node_modules/yet-another-react-lightbox/dist/core/modules/controller/useWheelSwipe.js"],"sourcesContent":["import * as React from \"react\";\nimport { useEventCallback } from \"../../hooks/index.js\";\nimport { useTimeouts } from \"../../contexts/index.js\";\nimport { SwipeState } from \"./index.js\";\nimport { EVENT_ON_WHEEL } from \"../../consts.js\";\nexport const useWheelSwipe = (swipeState, subscribeSensors, isSwipeValid, containerWidth, swipeAnimationDuration, onSwipeStart, onSwipeProgress, onSwipeFinish, onSwipeCancel) => {\n    const offset = React.useRef(0);\n    const intent = React.useRef(0);\n    const intentCleanup = React.useRef();\n    const resetCleanup = React.useRef();\n    const wheelResidualMomentum = React.useRef(0);\n    const startTime = React.useRef(0);\n    const { setTimeout, clearTimeout } = useTimeouts();\n    const cancelSwipeIntentCleanup = React.useCallback(() => {\n        if (intentCleanup.current) {\n            clearTimeout(intentCleanup.current);\n            intentCleanup.current = undefined;\n        }\n    }, [clearTimeout]);\n    const cancelSwipeResetCleanup = React.useCallback(() => {\n        if (resetCleanup.current) {\n            clearTimeout(resetCleanup.current);\n            resetCleanup.current = undefined;\n        }\n    }, [clearTimeout]);\n    const handleCleanup = useEventCallback(() => {\n        if (swipeState !== SwipeState.SWIPE) {\n            offset.current = 0;\n            startTime.current = 0;\n            cancelSwipeIntentCleanup();\n            cancelSwipeResetCleanup();\n        }\n    });\n    React.useEffect(handleCleanup, [swipeState, handleCleanup]);\n    const handleCancelSwipe = useEventCallback((currentSwipeOffset) => {\n        resetCleanup.current = undefined;\n        if (offset.current === currentSwipeOffset) {\n            onSwipeCancel(offset.current);\n        }\n    });\n    const onWheel = useEventCallback((event) => {\n        if (event.ctrlKey) {\n            return;\n        }\n        if (Math.abs(event.deltaY) > Math.abs(event.deltaX)) {\n            return;\n        }\n        if (!swipeState) {\n            if (Math.abs(event.deltaX) <= 1.2 * Math.abs(wheelResidualMomentum.current)) {\n                wheelResidualMomentum.current = event.deltaX;\n                return;\n            }\n            if (!isSwipeValid(-event.deltaX)) {\n                return;\n            }\n            intent.current += event.deltaX;\n            cancelSwipeIntentCleanup();\n            if (Math.abs(intent.current) > 30) {\n                intent.current = 0;\n                wheelResidualMomentum.current = 0;\n                startTime.current = Date.now();\n                onSwipeStart();\n            }\n            else {\n                const currentSwipeIntent = intent.current;\n                intentCleanup.current = setTimeout(() => {\n                    intentCleanup.current = undefined;\n                    if (currentSwipeIntent === intent.current) {\n                        intent.current = 0;\n                    }\n                }, swipeAnimationDuration);\n            }\n        }\n        else if (swipeState === SwipeState.SWIPE) {\n            let newSwipeOffset = offset.current - event.deltaX;\n            newSwipeOffset = Math.min(Math.abs(newSwipeOffset), containerWidth) * Math.sign(newSwipeOffset);\n            offset.current = newSwipeOffset;\n            onSwipeProgress(newSwipeOffset);\n            cancelSwipeResetCleanup();\n            if (Math.abs(newSwipeOffset) > 0.2 * containerWidth) {\n                wheelResidualMomentum.current = event.deltaX;\n                onSwipeFinish(newSwipeOffset, Date.now() - startTime.current);\n                return;\n            }\n            resetCleanup.current = setTimeout(() => handleCancelSwipe(newSwipeOffset), 2 * swipeAnimationDuration);\n        }\n        else {\n            wheelResidualMomentum.current = event.deltaX;\n        }\n    });\n    React.useEffect(() => subscribeSensors(EVENT_ON_WHEEL, onWheel), [subscribeSensors, onWheel]);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}